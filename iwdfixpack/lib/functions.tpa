// deleted effects which are now in WeiDU itself

/////                                                  \\\\\
///// item/spell functions                             \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION ALTER_AREA_AMBIENT
  INT_VAR coord_x = "-10" 
          coord_y = "-10"
          radius = "-10"
          height = "-10"
          pitch = "-10"
          volume_variation = "-10"
          volume = "-10"
          sounds = "-10"
          base_interval = "-10"
          interval_variation = "-10"
          flag_time_0 = "-10"
          flag_time_1 = "-10"
          flag_time_2 = "-10"
          flag_time_3 = "-10"
          flag_time_4 = "-10"
          flag_time_5 = "-10"
          flag_time_6 = "-10"
          flag_time_7 = "-10"
          flag_time_8 = "-10"
          flag_time_9 = "-10"
          flag_time_10 = "-10"
          flag_time_11 = "-10"
          flag_time_12 = "-10"
          flag_time_13 = "-10"
          flag_time_14 = "-10"
          flag_time_15 = "-10"
          flag_time_16 = "-10"
          flag_time_17 = "-10"
          flag_time_18 = "-10"
          flag_time_19 = "-10"
          flag_time_20 = "-10"
          flag_time_21 = "-10"
          flag_time_22 = "-10"
          flag_time_23 = "-10"
          flag_enabled = "-10"
          flag_looping = "-10"
          flag_ignore_radius = "-10"
          flag_random_order = "-10"
          flag_high_mem = "-10"
  STR_VAR ambient_name = ~~
          sound0 = null
          sound1 = null
          sound2 = null
          sound3 = null
          sound4 = null
          sound5 = null
          sound6 = null
          sound7 = null
          sound8 = null
          sound9 = null
BEGIN

  READ_SHORT 0x82 amb_num
  READ_LONG  0x84 amb_off
  FOR (index = 0 ; index < amb_num ; ++index) BEGIN
    READ_ASCII (amb_off + 0x00 + (index * 0xd4)) ambient_name_check (32) NULL
    PATCH_IF ("%ambient_name%" STRING_COMPARE_CASE "%ambient_name_check%" = 0) BEGIN
      PATCH_IF coord_x != "-10"            BEGIN WRITE_SHORT (amb_off + 0x20 + (index * 0xd4)) coord_x END
      PATCH_IF coord_y != "-10"            BEGIN WRITE_SHORT (amb_off + 0x22 + (index * 0xd4)) coord_y END
      PATCH_IF radius != "-10"             BEGIN WRITE_SHORT (amb_off + 0x24 + (index * 0xd4)) radius END
      PATCH_IF height != "-10"             BEGIN WRITE_SHORT (amb_off + 0x26 + (index * 0xd4)) height END
      PATCH_IF pitch != "-10"              BEGIN WRITE_LONG  (amb_off + 0x28 + (index * 0xd4)) pitch END
      PATCH_IF volume_variation != "-10"   BEGIN WRITE_SHORT (amb_off + 0x2c + (index * 0xd4)) volume_variation END
      PATCH_IF volume != "-10"             BEGIN WRITE_SHORT (amb_off + 0x2e + (index * 0xd4)) volume END
      PATCH_IF sounds != "-10"             BEGIN WRITE_SHORT (amb_off + 0x80 + (index * 0xd4)) sounds END
      PATCH_IF base_interval != "-10"      BEGIN WRITE_LONG  (amb_off + 0x84 + (index * 0xd4)) base_interval END
      PATCH_IF interval_variation != "-10" BEGIN WRITE_LONG  (amb_off + 0x88 + (index * 0xd4)) interval_variation END
      READ_LONG (amb_off + 0x8c + (index * 0xd4)) time
        PATCH_IF flag_time_0  = 0 BEGIN SET time = (time BAND `BIT0) END
        PATCH_IF flag_time_1  = 0 BEGIN SET time = (time BAND `BIT1) END
        PATCH_IF flag_time_2  = 0 BEGIN SET time = (time BAND `BIT2) END
        PATCH_IF flag_time_3  = 0 BEGIN SET time = (time BAND `BIT3) END
        PATCH_IF flag_time_4  = 0 BEGIN SET time = (time BAND `BIT4) END
        PATCH_IF flag_time_5  = 0 BEGIN SET time = (time BAND `BIT5) END
        PATCH_IF flag_time_6  = 0 BEGIN SET time = (time BAND `BIT6) END
        PATCH_IF flag_time_7  = 0 BEGIN SET time = (time BAND `BIT7) END
        PATCH_IF flag_time_8  = 0 BEGIN SET time = (time BAND `BIT8) END
        PATCH_IF flag_time_9  = 0 BEGIN SET time = (time BAND `BIT9) END
        PATCH_IF flag_time_10 = 0 BEGIN SET time = (time BAND `BIT10) END
        PATCH_IF flag_time_11 = 0 BEGIN SET time = (time BAND `BIT11) END
        PATCH_IF flag_time_12 = 0 BEGIN SET time = (time BAND `BIT12) END
        PATCH_IF flag_time_13 = 0 BEGIN SET time = (time BAND `BIT13) END
        PATCH_IF flag_time_14 = 0 BEGIN SET time = (time BAND `BIT14) END
        PATCH_IF flag_time_15 = 0 BEGIN SET time = (time BAND `BIT15) END
        PATCH_IF flag_time_16 = 0 BEGIN SET time = (time BAND `BIT16) END
        PATCH_IF flag_time_17 = 0 BEGIN SET time = (time BAND `BIT17) END
        PATCH_IF flag_time_18 = 0 BEGIN SET time = (time BAND `BIT18) END
        PATCH_IF flag_time_19 = 0 BEGIN SET time = (time BAND `BIT19) END
        PATCH_IF flag_time_20 = 0 BEGIN SET time = (time BAND `BIT20) END
        PATCH_IF flag_time_21 = 0 BEGIN SET time = (time BAND `BIT21) END
        PATCH_IF flag_time_22 = 0 BEGIN SET time = (time BAND `BIT22) END
        PATCH_IF flag_time_23 = 0 BEGIN SET time = (time BAND `BIT23) END
        PATCH_IF flag_time_0  = 1 BEGIN SET time = (time BOR BIT0) END
        PATCH_IF flag_time_1  = 1 BEGIN SET time = (time BOR BIT1) END
        PATCH_IF flag_time_2  = 1 BEGIN SET time = (time BOR BIT2) END
        PATCH_IF flag_time_3  = 1 BEGIN SET time = (time BOR BIT3) END
        PATCH_IF flag_time_4  = 1 BEGIN SET time = (time BOR BIT4) END
        PATCH_IF flag_time_5  = 1 BEGIN SET time = (time BOR BIT5) END
        PATCH_IF flag_time_6  = 1 BEGIN SET time = (time BOR BIT6) END
        PATCH_IF flag_time_7  = 1 BEGIN SET time = (time BOR BIT7) END
        PATCH_IF flag_time_8  = 1 BEGIN SET time = (time BOR BIT8) END
        PATCH_IF flag_time_9  = 1 BEGIN SET time = (time BOR BIT9) END
        PATCH_IF flag_time_10 = 1 BEGIN SET time = (time BOR BIT10) END
        PATCH_IF flag_time_11 = 1 BEGIN SET time = (time BOR BIT11) END
        PATCH_IF flag_time_12 = 1 BEGIN SET time = (time BOR BIT12) END
        PATCH_IF flag_time_13 = 1 BEGIN SET time = (time BOR BIT13) END
        PATCH_IF flag_time_14 = 1 BEGIN SET time = (time BOR BIT14) END
        PATCH_IF flag_time_15 = 1 BEGIN SET time = (time BOR BIT15) END
        PATCH_IF flag_time_16 = 1 BEGIN SET time = (time BOR BIT16) END
        PATCH_IF flag_time_17 = 1 BEGIN SET time = (time BOR BIT17) END
        PATCH_IF flag_time_18 = 1 BEGIN SET time = (time BOR BIT18) END
        PATCH_IF flag_time_19 = 1 BEGIN SET time = (time BOR BIT19) END
        PATCH_IF flag_time_20 = 1 BEGIN SET time = (time BOR BIT20) END
        PATCH_IF flag_time_21 = 1 BEGIN SET time = (time BOR BIT21) END
        PATCH_IF flag_time_22 = 1 BEGIN SET time = (time BOR BIT22) END
        PATCH_IF flag_time_23 = 1 BEGIN SET time = (time BOR BIT23) END
      WRITE_LONG (amb_off + 0x8c + (index * 0xd4)) time
      READ_LONG  (amb_off + 0x90 + (index * 0xd4)) flags
        PATCH_IF flag_enabled       = 0 BEGIN SET flags = (flags BAND `BIT0) END
        PATCH_IF flag_looping       = 0 BEGIN SET flags = (flags BAND `BIT1) END
        PATCH_IF flag_ignore_radius = 0 BEGIN SET flags = (flags BAND `BIT2) END
        PATCH_IF flag_random_order  = 0 BEGIN SET flags = (flags BAND `BIT3) END
        PATCH_IF flag_high_mem      = 0 BEGIN SET flags = (flags BAND `BIT4) END
        PATCH_IF flag_enabled       = 1 BEGIN SET flags = (flags BOR BIT0) END
        PATCH_IF flag_looping       = 1 BEGIN SET flags = (flags BOR BIT1) END
        PATCH_IF flag_ignore_radius = 1 BEGIN SET flags = (flags BOR BIT2) END
        PATCH_IF flag_random_order  = 1 BEGIN SET flags = (flags BOR BIT3) END
        PATCH_IF flag_high_mem      = 1 BEGIN SET flags = (flags BOR BIT4) END
      WRITE_LONG (amb_off + 0x90 + (index * 0xd4)) flags
      PATCH_IF ("%sound0%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x30 + (index * 0xd4)) "%sound0%" #8 END
      PATCH_IF ("%sound1%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x38 + (index * 0xd4)) "%sound1%" #8 END
      PATCH_IF ("%sound2%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x40 + (index * 0xd4)) "%sound2%" #8 END
      PATCH_IF ("%sound3%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x48 + (index * 0xd4)) "%sound3%" #8 END
      PATCH_IF ("%sound4%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x50 + (index * 0xd4)) "%sound4%" #8 END
      PATCH_IF ("%sound5%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x58 + (index * 0xd4)) "%sound5%" #8 END
      PATCH_IF ("%sound6%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x60 + (index * 0xd4)) "%sound6%" #8 END
      PATCH_IF ("%sound7%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x68 + (index * 0xd4)) "%sound7%" #8 END
      PATCH_IF ("%sound8%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x70 + (index * 0xd4)) "%sound8%" #8 END
      PATCH_IF ("%sound9%" STRING_COMPARE_CASE "null") BEGIN WRITE_ASCIIE (amb_off + 0x78 + (index * 0xd4)) "%sound9%" #8 END
    END // end ambient name check
  END // end for loop

END // end function
  
/////                                                  \\\\\
///// item/spell functions                             \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION CONVERT_BG_IWD_DURATION
  STR_VAR changeto = "iwd" // iwd changes effects to use round = 7; otherwise use round = 6
  BEGIN

  READ_LONG  0x6a fx_off
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  PATCH_IF ("%SOURCE_FILE%" STRING_COMPARE_REGEXP "^.+\.itm" = 0) BEGIN SET abil_length = 0x38 END ELSE BEGIN SET abil_length = 0x28 END
  PATCH_IF (abil_num > 0) BEGIN // if there are headers, figure out the final effect
    READ_SHORT (abil_off + 0x1e + ((abil_num - 1) * abil_length)) abil_fx_num
    READ_SHORT (abil_off + 0x20 + ((abil_num - 1) * abil_length)) abil_fx_idx
    SET fx_num = abil_fx_num + abil_fx_idx
  END ELSE BEGIN // else read the last global
    READ_SHORT 0x70 fx_num
  END
  FOR (index = 0 ; index < fx_num ; ++index) BEGIN
    READ_LONG (fx_off + 0x0e + (index * 0x30)) duration
    PATCH_IF (duration > 5) BEGIN // skip 0 duration or short lived cosmetic/auditory
      PATCH_IF ("iwd" STRING_COMPARE_CASE "%changeto%" = 0) BEGIN
        WRITE_LONG (fx_off + 0x0e + (index * 0x30)) ((duration * 7) / 6)
      END ELSE BEGIN
        WRITE_LONG (fx_off + 0x0e + (index * 0x30)) ((duration * 6) / 7)
      END
    END
  END

END
  
/////                                                  \\\\\
///// items casting spells                             \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION cd_weapon_speed // updates weapon speed and item description
  INT_VAR speed = "-1"
  BEGIN
  
  PATCH_IF speed >= 0 BEGIN // must have speed set in function
    READ_LONG  0x64 abil_off
    READ_SHORT 0x68 abil_num
    FOR (index = 0 ; index < abil_num ; ++index) BEGIN
      READ_BYTE (abil_off + 0x00 + (index * 0x38)) abil_type
      PATCH_IF ((abil_type = 1) OR (abil_type = 2) OR (abil_type = 4)) BEGIN // melee, ranged, launcher
        WRITE_SHORT (abil_off + 0x12 + (index * 0x38)) speed // set new speed in-game
      END
    END
    FOR (index = 0x54 ; index > 0x4f ; index -= 0x04) BEGIN // only if no identified descript to match and update, go after normal descript (blun04)
      READ_LONG index desc_strref
      PATCH_IF ((desc_strref >= 0) AND (desc_strref < 999999)) BEGIN
        READ_STRREF index desc
        INNER_PATCH_SAVE desc ~%desc%~ BEGIN
          REPLACE_TEXTUALLY ~%text_match_speed%~ ~\1%speed%~
        END
        INNER_ACTION BEGIN
          STRING_SET_EVALUATE desc_strref ~%desc%~
        END
        SET index = 0 // kill loop (if identified updated, don't mess with unidentified)
      END
    END
  END  

END
  
/////                                                  \\\\\
///// items casting spells                             \\\\\
/////                                                  \\\\\

DEFINE_ACTION_FUNCTION cd_items_casting_spells
  INT_VAR cast_at_level = 1
          duration      = 0
          item_header   = "-1"
          probability   = 0 
          set_icon      = 0
  STR_VAR item  = null
          spell = null
  BEGIN
  
  ACTION_IF FILE_EXISTS_IN_GAME ~%spell%.spl~ AND
            FILE_EXISTS_IN_GAME ~%item%.itm~ AND
            item_header >= 0 BEGIN
            
    COPY_EXISTING ~%spell%.spl~ ~override~
      READ_SHORT 0x68 abil_num
      READ_LONG  0x64 abil_off
      READ_LONG  0x6a fx_off
      PATCH_IF ((abil_num = 1) OR (cast_at_level = 1)) BEGIN
        SET base_off = abil_off
      END ELSE BEGIN  
        FOR (index = 1 ; index < abil_num ; ++index) BEGIN // skip first ability
          READ_SHORT (abil_off + 0x10 + (index * 0x28)) min_lev
          PATCH_IF min_lev = cast_at_level BEGIN
            SET base_off = (abil_off + 0x00 + (index * 0x28))
            SET index = abil_num // kill loop
          END  
          PATCH_IF min_lev < cast_at_level BEGIN
            SET base_off = (abil_off + 0x00 + ((index - 1) * 0x28))
            SET index = abil_num // kill loop
          END  
        END
      END
      READ_ASCII (base_off + 0x04) icon
      READ_SHORT (base_off + 0x1e) transfer_fx_num
      READ_SHORT (base_off + 0x20) abil_fx_idx 
      READ_ASCII (fx_off + (abil_fx_idx * 0x30)) transfer_effects (0x30 * transfer_fx_num) // read all effects in a massive block
      BUT_ONLY
    
    COPY_EXISTING ~%item%.itm~ ~override~    
      READ_SHORT 0x68 abil_num
      READ_LONG  0x64 abil_off
      READ_LONG  0x6a fx_off
      SET fx_delta = 0
      FOR (index = 0 ; index < abil_num + 1 ; ++index) BEGIN
        PATCH_IF index = 0 BEGIN // global effect loop
          SET abil_fx_idx_off = 0x6e
          SET abil_fx_num_off = 0x70
        END ELSE BEGIN           // ability loops
          SET abil_fx_idx_off = (abil_off + 0x20 + ((index - 1) * 0x38))
          SET abil_fx_num_off = (abil_off + 0x1e + ((index - 1) * 0x38))
        END 
        WRITE_SHORT  abil_fx_idx_off (THIS + fx_delta)         // update with previously inserted effects
        PATCH_IF index = item_header BEGIN                     // if we're in the correct header
          PATCH_IF set_icon AND item_header BEGIN
            WRITE_ASCIIE (abil_fx_idx_off - 0x1c) ~%icon%~ #8  // update icon, if indicated
          END  
          SET fx_delta += transfer_fx_num                      // update delta
          READ_SHORT abil_fx_idx_off abil_fx_idx               // read updated index
          WRITE_SHORT abil_fx_num_off (THIS + transfer_fx_num) // update number of effects
          SET base_fx_add = (fx_off + 0x00 + (abil_fx_idx * 0x30))
          INSERT_BYTES base_fx_add (0x30 * transfer_fx_num)            // make space for...
          WRITE_ASCIIE base_fx_add ~%transfer_effects%~                // transferred effects
          FOR (index2 = 0 ; index2 < transfer_fx_num ; ++index2) BEGIN // loop through newly-inserted effects
            READ_ASCII (base_fx_add + 0x14 + (0x30 * index2)) resref
            PATCH_IF ("%resref%" STRING_COMPARE_CASE "%spell%" = 0) BEGIN 
              WRITE_ASCIIE (base_fx_add + 0x14 + (0x30 * index2)) "%item%" #8 // if self-reference, update
            END // end self-reference check
            PATCH_IF duration BEGIN                                       // if custom duration set, update duration
              READ_LONG (base_fx_add + 0x0e + (0x30 * index2)) fx_dur
              PATCH_IF fx_dur > 6 BEGIN                                   // skip instant effects
                WRITE_LONG (base_fx_add + 0x0e + (0x30 * index2)) duration
              END // duration length check
            END // custom duration check
            PATCH_IF probability BEGIN                                    // if custom probability set, scale probabilities
              WRITE_BYTE (base_fx_add + 0x12 + (0x30 * index2)) ((THIS * probability) / 100) 
              WRITE_BYTE (base_fx_add + 0x13 + (0x30 * index2)) ((THIS * probability) / 100) 
            END // custom probability check
          END // end new fx loop
        END // end header match check
      END // end main for loop 
      BUT_ONLY      
            
  END ELSE BEGIN
  
    WARN ~cd_items_casting_spells: file(s) not found or invalid input~
    
  END

END  
  
/////                                                  \\\\\
///// phasing conversion                               \\\\\
/////                                                  \\\\\

DEFINE_PATCH_MACRO cd_convert_phasing BEGIN 
    
  READ_SHORT 0x68 abil_num
  READ_LONG  0x64 abil_off
  READ_LONG  0x6a fx_off
  SET fx_delta = 0
  FOR (index = 0 ; index < abil_num + 1 ; ++index) BEGIN
    WRITE_SHORT (abil_off + 0x20 + (index * 0x38)) (THIS + fx_delta)         // update with previously inserted effects
    READ_SHORT  (abil_off + 0x20 + (index * 0x38)) abil_fx_idx               // read updated index
    READ_SHORT  (abil_off + 0x1e + (index * 0x38)) abil_fx_num               // update number of effects
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_SHORT (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) opcode
      PATCH_IF opcode = 78 BEGIN
        READ_LONG (fx_off + 0x04 + ((abil_fx_idx + index2) * 0x30)) param1
        READ_LONG (fx_off + 0x08 + ((abil_fx_idx + index2) * 0x30)) param2
        READ_LONG (fx_off + 0x0e + ((abil_fx_idx + index2) * 0x30)) duration
        PATCH_IF param2 = 2 BEGIN // param1 damage per second 
          WRITE_SHORT (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30))         12 // op: damage
          WRITE_SHORT (fx_off + 0x08 + ((abil_fx_idx + index2) * 0x30))          0 // normal
          WRITE_SHORT (fx_off + 0x0a + ((abil_fx_idx + index2) * 0x30))         64 // magic
          WRITE_BYTE  (fx_off + 0x0c + ((abil_fx_idx + index2) * 0x30))          1 // timing: permanent
          WRITE_LONG  (fx_off + 0x0e + ((abil_fx_idx + index2) * 0x30))          0 // duration
          WRITE_LONG  (fx_off + 0x1c + ((abil_fx_idx + index2) * 0x30))          0 // num dice
          WRITE_LONG  (fx_off + 0x20 + ((abil_fx_idx + index2) * 0x30))          0 // dice size
          READ_ASCII  (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) clone (48) // clone it for subsequent
          FOR (index3 = 1 ; index3 < duration; ++index3) BEGIN
            SET fx_delta    += 1
            SET index2      += 1
            SET abil_fx_num += 1
            INSERT_BYTES (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30))      0x30 // insert bytes for new effect
            WRITE_ASCIIE (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) ~%clone%~ // clone in original magic damage effect
            WRITE_BYTE   (fx_off + 0x0c + ((abil_fx_idx + index2) * 0x30))         4 // timing: delay/permanent
            WRITE_LONG   (fx_off + 0x0e + ((abil_fx_idx + index2) * 0x30))    index3 // duration
          END
        END    
        PATCH_IF param2 = 3 BEGIN // 1 damage per param1 seconds 
          WRITE_SHORT (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30))         12 // op: damage
          WRITE_SHORT (fx_off + 0x04 + ((abil_fx_idx + index2) * 0x30))          1 // 1 damage
          WRITE_SHORT (fx_off + 0x08 + ((abil_fx_idx + index2) * 0x30))          0 // normal
          WRITE_SHORT (fx_off + 0x0a + ((abil_fx_idx + index2) * 0x30))         64 // magic
          WRITE_BYTE  (fx_off + 0x0c + ((abil_fx_idx + index2) * 0x30))          1 // timing: permanent
          WRITE_LONG  (fx_off + 0x0e + ((abil_fx_idx + index2) * 0x30))          0 // duration
          READ_ASCII  (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) clone (48) // clone it for subsequent
          FOR (index3 = param1 ; index3 < duration; index3 = (index3 + param1)) BEGIN
            SET fx_delta    += 1
            SET index2      += 1
            SET abil_fx_num += 1
            INSERT_BYTES (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30))      0x30 // insert bytes for new effect
            WRITE_ASCIIE (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) ~%clone%~ // clone in original magic damage effect
            WRITE_BYTE   (fx_off + 0x0c + ((abil_fx_idx + index2) * 0x30))         4 // timing: delay/permanent
            WRITE_LONG   (fx_off + 0x0e + ((abil_fx_idx + index2) * 0x30))    index3 // duration
          END
        END
      END // op = 78 check  
    END // fx loop in current ability  
    WRITE_SHORT  (abil_off + 0x1e + (index * 0x38)) abil_fx_num               // update number of effects 
  END // end ability loop  
  
END

// do spell stacking via function; basically we want to insert the 254 *after* any of IWD's 206/290 protections, e.g.
// you don't want the dispel running ahead of an evasion check or, say, an undead immunity

DEFINE_PATCH_FUNCTION cd_spell_stacking
  INT_VAR cloneop = "-1"
  BEGIN
  
  PATCH_IF ("%SOURCE_FILE%" STRING_COMPARE_REGEXP "^.+\.itm" = 0) BEGIN SET abil_length = 0x38 END ELSE BEGIN SET abil_length = 0x28 END
  READ_SHORT 0x68 abil_num
  READ_LONG  0x64 abil_off
  READ_LONG  0x6a fx_off
  SET delta = 0 
  FOR (index = 0 ; index < abil_num; ++index) BEGIN
    READ_SHORT  (abil_off + 0x1e + (index * abil_length)) abil_fx_num
    WRITE_SHORT (abil_off + 0x20 + (index * abil_length)) (THIS + delta)
    READ_SHORT  (abil_off + 0x20 + (index * abil_length)) abil_fx_idx
    SET insert_point_check = 0
    SET inserted = 0
    SET insert_point = (fx_off + 0x00 + (abil_fx_idx * 0x30)) 
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_SHORT (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) op
      READ_ASCII (fx_off + 0x14 + ((abil_fx_idx + index2) * 0x30)) resref
      PATCH_IF (((op = 206) OR (op = 290)) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "%resref%" = 0) AND (!insert_point_check)) BEGIN // blocking effects via 206 or 290
        SET insert_point = (fx_off + 0x00 + ((abil_fx_idx + index2 + 1) * 0x30)) 
      END ELSE BEGIN
        SET insert_point_check = 1
      END     
      PATCH_IF (((op = 206) OR (op = 290)) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "%resref%" = 0) AND (insert_point_check)) BEGIN // blocking effects via 206 or 290
        READ_LONG (fx_off + 0x08 + ((abil_fx_idx + index2) * 0x30)) param2
        PATCH_IF !param2 BEGIN
          DELETE_BYTES (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) 0x30 // delete effect    
          SET abil_fx_num -= 1   
          SET delta -= 1
          SET index2 -= 1
        END
      END        
      PATCH_IF ((op = cloneop) AND (!inserted)) BEGIN // if op to clone
        SET inserted = 1
        READ_ASCII (fx_off + 0x00 + ((abil_fx_idx + index2) * 0x30)) clone (0x30)
        INSERT_BYTES insert_point 0x30
        WRITE_ASCIIE insert_point ~%clone%~ #48
        WRITE_SHORT  (insert_point + 0x00) 254 // opcode: dispel specific spell   
        WRITE_LONG   (insert_point + 0x04)   0 // blank parameter1   
        WRITE_LONG   (insert_point + 0x08)   0 // dispel all effects      
        WRITE_BYTE   (insert_point + 0x0c)   1 // timing: instant/perm
        WRITE_LONG   (insert_point + 0x0e)   0 // duration     
        WRITE_ASCIIE (insert_point + 0x14) ~%SOURCE_RES%~ #8 // self-ref   
        WRITE_LONG   (insert_point + 0x1c)   0 // dice num     
        WRITE_LONG   (insert_point + 0x20)   0 // dice size     
        SET abil_fx_num += 1   
        SET delta += 1
        SET index2 += 1
      END  
    END
    WRITE_SHORT  (abil_off + 0x1e + (index * abil_length)) abil_fx_num // update 
  END

END  

/////                                                  \\\\\
///// miscellaneous creature inventory macros          \\\\\
/////                                                  \\\\\

// this function takes an item listed in a creture file and moves it to an open slot
// it'll try the appropriate slot first and then move to inventory
// same as functions from bg2 fixpack, except reading different offsets for slot_off, item_off, and item_num
DEFINE_PATCH_FUNCTION cd_equip_item

  // defines what we're going to check
  INT_VAR move = 0
          gpuse = 0
  STR_VAR item = "same"
          slot = "helmet"

BEGIN

  SET fruitbats = "-1"
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "helmet" = 0) BEGIN
    SET start = 0
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "armor" = 0) BEGIN
    SET start = 1
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "shield" = 0) BEGIN
    SET start = 2
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "gloves" = 0) BEGIN
    SET start = 3
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "rings" = 0) BEGIN
    SET start = 4
    SET fruitbats = 5
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "amulet" = 0) BEGIN
    SET start = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "jewelry" = 0) BEGIN
    SET start = 4
    SET fruitbats = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "belt" = 0) BEGIN
    SET start = 7
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "boots" = 0) BEGIN
    SET start = 8
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "weapon" = 0) BEGIN
    SET start = 9
    SET fruitbats = 12
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quiver" = 0) BEGIN
    SET start = 13
    SET fruitbats = 15
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quickslot" = 0) BEGIN
    SET start = 18
    SET fruitbats = 20
  END ELSE BEGIN // inventory
    PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
      SET start = 21
    END ELSE BEGIN
      SET start = 23
    END
    SET fruitbats = 0
  END
  PATCH_IF fruitbats < 0 BEGIN SET fruitbats = start END

  READ_LONG 0x320 slot_off ELSE 0
  READ_LONG 0x324 itm_off  ELSE 0
  READ_LONG 0x328 itm_num  ELSE 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) test_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%test_item%" = 0) BEGIN
      SET proceed = 1
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
        READ_SHORT (slot_off + (index2 * 0x02)) ref
        PATCH_IF ref = index BEGIN
          PATCH_IF move = 1 BEGIN
            WRITE_SHORT (slot_off + (index2 * 0x02)) 0xffff
          END ELSE BEGIN
            SET proceed = 0
          END
        END
      END
      PATCH_IF proceed BEGIN
        FOR (index2 = start ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
          READ_SHORT (slot_off + (index2 * 0x02)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if null reference in targeted slot
            WRITE_SHORT (slot_off + (index2 * 0x02)) index // adds reference to item
            SET index2 = 36 // kills loop
          END
          PATCH_IF (index2 = fruitbats) BEGIN // if end of possible equipment slots, skip ahead to inventory
            PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
              SET index2 = 20 // otherwise go to inventory slots
            END ELSE BEGIN
              SET index2 = 22 // otherwise go to inventory slots
            END
          END
        END
      END
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon BEGIN

  READ_LONG 0x320 slot_off ELSE 0
  READ_LONG 0x328 itm_num  ELSE 0
  WRITE_SHORT (slot_off + 0x4c) 0xffff // null equipped weapon - either patch below will enter a valid value, or no valid value exists
  FOR (index = 0 ; index < 4 ; ++index) BEGIN // search through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) ref
    PATCH_IF ((ref != 0xffff) AND (ref < itm_num)) BEGIN // if valid reference in weapon slots
//    PATCH_IF (ref != 0xffff) BEGIN // if valid reference in weapon slots
      WRITE_SHORT (slot_off + 0x4c) index // equipped weapon
      SET "index" = 4 // kills loop and prevents next patch_if
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon_specific

  // defines what we're going to check
  STR_VAR item = ""

BEGIN


  READ_LONG 0x320 slot_off ELSE 0
  READ_LONG 0x324 itm_off  ELSE 0
  FOR (index = 0; index < 4; ++index) BEGIN // cycles through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) slot_num
    PATCH_IF (slot_num < 37) BEGIN
      READ_ASCII (itm_off + (slot_num * 0x14)) weapon
      PATCH_IF ("%item%" STRING_COMPARE_CASE "%weapon%" = 0) BEGIN // if long sword
        WRITE_SHORT (slot_off + 0x4c) index // sets weapon slot to selected weapon
        SET index = 4
      END
    END
  END

END

// this function moves an item in a creture file into a slot where it can't be pickocketed
// also used to move items out of helmet slot for non-legit crit protection
DEFINE_PATCH_FUNCTION cd_no_pickpocket

  // defines what we're going to check
  STR_VAR item = ""

BEGIN

  READ_LONG 0x320 slot_off ELSE 0
  READ_LONG 0x324 itm_off  ELSE 0
  READ_LONG 0x328 itm_num  ELSE 0
  SET added = 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) file_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%file_item%" = 0) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // search through item slots; first pass finds and/or removes
        READ_SHORT (slot_off + (0x02 * index2)) ref
        PATCH_IF (ref = index) BEGIN // if item in question
          PATCH_IF ((index2 = 1) OR (index2 = 3) OR ((index2 > 6) AND (index2 < 18))) BEGIN // if legit slot (1, 3, 7-17)
            SET added = 1
          END ELSE BEGIN
            WRITE_SHORT (slot_off + (0x02 * index2)) 0xffff // nulls reference
          END
        END
      END
      PATCH_IF added = 0 BEGIN // if not in a legit slot to begin with
        FOR (index2 = 1 ; index2 < 36 ; ++index2) BEGIN // search through item slots (skipping helmet at 0); first pass finds and/or removes
          PATCH_IF (index2 =  2) BEGIN SET index2 =  3 END // skip shield slot
          PATCH_IF (index2 =  4) BEGIN SET index2 =  7 END // skip rings & amulet
          PATCH_IF (index2 = 18) BEGIN SET index2 = 21 END // skip quick slots
          READ_SHORT (slot_off + (0x02 * index2)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if empty, legit slot
            WRITE_SHORT (slot_off + (0x02 * index2)) index // adds reference
            SET index  = itm_num  // kill loops
            SET index2 = 36       // kill loops
          END
        END
      END
    END
  END

END

// DELETE_CRE_ITEM assumes creature file v1, not oIWD's v9

DEFINE_PATCH_FUNCTION ~DELETE_CRE_ITEM_V9~
  STR_VAR item_to_delete = ~blank~
BEGIN
  
  READ_LONG 0x320 slot_off ELSE 0
  READ_LONG 0x324 itm_off  ELSE 0
  READ_LONG 0x328 itm_num  ELSE 0
  SET delta = 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) file_item
    PATCH_IF (("%file_item%" STRING_MATCHES_REGEXP "%item_to_delete%" = 0) OR
              (("%file_item%" STRING_COMPARE_CASE ~~ = 0) AND ("%item_to_delete%" STRING_COMPARE_CASE ~blank~ = 0))) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // search through item slots; first pass finds and/or removes
        READ_SHORT (slot_off + (0x02 * index2) - (delta * 0x14)) ref
        PATCH_IF (ref = index) BEGIN // if item in question
          WRITE_SHORT (slot_off + (0x02 * index2) - (delta * 0x14)) 0xffff // nulls reference
        END ELSE 
        PATCH_IF ((ref > index) AND (ref != 0xffff)) BEGIN // if after item in question
          WRITE_SHORT (slot_off + (0x02 * index2) - (delta * 0x14)) (THIS - 1) // move up one
        END   
      END
      DELETE_BYTES (itm_off + (0x14 * index)) 0x14 // delete item
      SET delta += 1
      SET index -= 1
    END // end item match
  END // end main item loop
  PATCH_IF delta BEGIN // if changes, fix offsets and item count
    WRITE_LONG 0x328 THIS - delta
    PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x32c BEGIN
      READ_LONG offset off
      PATCH_IF off > itm_off BEGIN
        WRITE_LONG offset (THIS - (delta * 0x14))
      END
    END
  END    
  
END

